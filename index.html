<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TaxReligion's Factions Simulator (JS)</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            padding: 1em;
            background-color: #f4f4f4;
        }

        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            width: 95%;
            max-width: 1400px; /* Adjust as needed */
        }

        /* Tab styling */
        .tab-container {
            display: flex;
            border-bottom: 1px solid #ccc;
            margin-bottom: 15px;
        }
        .tab-button {
            padding: 10px 15px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-right: 5px;
            background-color: #eee;
            border-radius: 5px 5px 0 0;
        }
        .tab-button.active {
            background-color: #fff;
            border-color: #ccc #ccc #fff;
        }
        .tab-content {
            display: none;
            padding: 15px;
            border: 1px solid #ccc;
            border-top: none;
            border-radius: 0 0 5px 5px;
        }
        .tab-content.active {
            display: block;
        }

        /* General layout */
        .section {
            margin-bottom: 15px;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
            background-color: #fafafa;
        }
        .section legend {
            font-weight: bold;
            padding: 0 5px;
        }
        fieldset {
             border: 1px solid #ddd;
             padding: 10px;
             margin-bottom: 10px;
        }
        legend {
            font-weight: bold;
            padding: 0 5px;
            color: #333;
        }


        button {
            padding: 8px 12px;
            margin: 5px 2px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #e7e7e7;
        }
        button:hover {
            background-color: #ddd;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        button.can-afford {
            background-color: #4CAF50; /* Green */
            color: white;
            border-color: #4CAF50;
        }
        button.can-afford:hover {
            background-color: #45a049;
        }
         button.delete-button {
            background-color: #f44336; /* Red */
            color: white;
            border-color: #d32f2f;
            padding: 4px 8px; /* Smaller delete button */
            margin-left: 5px;
        }
        button.delete-button:hover {
            background-color: #da190b;
        }

        input[type="text"], input[type="number"], select {
            padding: 6px;
            margin: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box; /* Include padding and border in element's total width/height */
        }
        input[type="number"] {
            width: 80px; /* Adjust width for number inputs */
        }
         select {
            min-width: 150px;
        }

        .grid-container {
            display: grid;
            gap: 10px;
        }

        .flex-container {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping */
        }
        .flex-container > button {
             flex-grow: 1; /* Allow buttons to grow */
        }

        /* Village Tab Layout */
        .village-tab-grid {
            display: grid;
            grid-template-columns: 1fr 2fr; /* Left column takes 1 part, right takes 2 */
            gap: 20px;
        }
        .left-column, .right-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .right-column {
            min-width: 0; /* Prevent flex item from overflowing */
        }

        /* Status Table */
        .status-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 10px;
        }
        .status-table th, .status-table td {
            border: 1px solid #ddd;
            padding: 6px 8px;
            text-align: left;
            min-width: 50px; /* Ensure minimum width */
        }
        .status-table th {
            background-color: #f2f2f2;
            font-size: 0.9em;
        }
        .status-table td {
             font-size: 0.9em;
             word-break: break-word; /* Prevent long words from breaking layout */
        }
        .status-info {
            font-weight: bold;
            margin-top: 5px;
            font-size: 0.9em;
        }
        .goal-status-label {
             margin-top: 10px;
             padding: 8px;
             background-color: #eef;
             border: 1px solid #ccd;
             border-radius: 4px;
             font-size: 0.9em;
             min-height: 3em; /* Give it some height */
             display: block; /* Ensure it takes full width */
        }


        /* Building List */
        .building-list-container {
            border: 1px solid #ccc;
            padding: 10px;
            max-height: 400px; /* Adjust as needed */
            overflow-y: auto;
            flex-grow: 1; /* Allow this to take available space */
        }
        .building-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px dashed #eee;
        }
         .building-item button:first-child { /* Upgrade button */
             flex-grow: 1; /* Take available space */
             margin-right: 5px;
             text-align: left;
             font-size: 0.85em; /* Smaller font for upgrade button */
         }
         .building-item button.delete-button {
             flex-shrink: 0; /* Prevent delete button from shrinking */
         }

        /* Modifier Grids */
        .modifier-grid {
            display: grid;
            grid-template-columns: auto repeat(3, 1fr); /* Label + 3 columns */
            gap: 5px 10px; /* Row gap, Column gap */
            align-items: center;
        }
        .modifier-grid label {
            text-align: right;
            font-weight: bold;
            font-size: 0.9em;
        }
        .modifier-grid input {
            width: 90%; /* Make inputs fill cell better */
            justify-self: center; /* Center input in grid cell */
        }
        .modifier-grid .header {
            text-align: center;
            font-weight: bold;
            font-size: 0.9em;
        }

        .terrain-modifier-grid {
            display: grid;
            grid-template-columns: auto repeat(2, 1fr); /* Label + 2 columns */
            gap: 5px 10px;
            align-items: center;
        }
        .terrain-modifier-grid label, .terrain-modifier-grid .header {
            font-weight: bold;
            font-size: 0.9em;
        }
        .terrain-modifier-grid label { text-align: right; }
        .terrain-modifier-grid .header { text-align: center; }
        .terrain-modifier-grid input {
            width: 90%;
             justify-self: center;
        }

        /* Conversion Calculator */
        .conversion-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 5px;
            margin-bottom: 10px;
            background: #f9f9f9;
        }
        .conversion-list li {
            padding: 3px 5px;
            border-bottom: 1px dotted #eee;
            font-size: 0.9em;
        }
         .conversion-list li:last-child {
             border-bottom: none;
         }
        .total-costs-display {
            white-space: pre-wrap; /* Allow newlines */
            font-family: monospace;
            background-color: #eee;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
            margin-top: 10px;
            font-size: 0.9em;
        }

        /* Add Building Modal */
        #addBuildingModal {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            width: 80%;
            max-width: 600px;
        }
        #addBuildingModal::backdrop {
          background: rgba(0, 0, 0, 0.5);
        }
        #addBuildingModal h3 {
            margin-top: 0;
        }
        .modal-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); /* Responsive grid */
            gap: 10px;
            margin-bottom: 15px;
        }
        .modal-grid button {
            width: 100%;
            text-align: left;
            font-size: 0.9em;
             white-space: normal; /* Allow button text to wrap */
             height: 4em; /* Give buttons consistent height */
             display: flex; /* For vertical alignment if needed */
             align-items: center;
             justify-content: center;
             text-align: center;
        }
        .modal-close-button {
            display: block; /* Make it block to center */
            margin: 15px auto 0 auto; /* Add top margin and center */
        }

        /* Footer/Tick Counter */
        .tick-counter {
             margin-top: 20px;
             font-weight: bold;
             color: #555;
        }

        /* Utility */
        .hidden { display: none; }
        .error-message { color: red; font-weight: bold; margin-top: 5px; }

    </style>
</head>
<body>
    <div class="container">
        <h1>TaxReligion's Factions Simulator (JS Version)</h1>

        <!-- Tabs -->
        <div class="tab-container">
            <button class="tab-button active" onclick="openTab(event, 'villageTab')">Village</button>
            <button class="tab-button" onclick="openTab(event, 'conversionTab')">Conversion Calculator</button>
            <button class="tab-button" onclick="openTab(event, 'scenarioTab')">Scenario Controls</button>
        </div>

        <!-- Village Tab -->
        <div id="villageTab" class="tab-content active">
             <div class="flex-container" style="margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px;">
                <label for="logFileLoad" class="button-like">Load Log
                     <input type="file" id="logFileLoad" accept=".txt" class="hidden">
                </label>
                <button id="saveLogButton">Save Log</button>
                <button id="revertButton">Revert Last Action</button>
            </div>

            <div class="village-tab-grid">
                <!-- Left Column -->
                <div class="left-column">
                    <fieldset class="section">
                        <legend>Scaling Factors (Multiplier)</legend>
                        <div class="modifier-grid">
                            <span class="header"></span><span class="header">Wood</span><span class="header">Iron</span><span class="header">Workers</span>
                            <label for="sf_building_wood">Buildings</label>
                            <input type="number" id="sf_building_wood" step="0.01" value="1.0">
                            <input type="number" id="sf_building_iron" step="0.01" value="1.0">
                            <input type="number" id="sf_building_workers" step="0.01" value="1.0">
                            <label for="sf_hq_wood">HQ</label>
                            <input type="number" id="sf_hq_wood" step="0.01" value="1.0">
                            <input type="number" id="sf_hq_iron" step="0.01" value="1.0">
                            <input type="number" id="sf_hq_workers" step="0.01" value="1.0">
                        </div>
                         <button id="saveScalingFactorsButton" style="margin-top: 10px; width: 100%;">Save Scaling Factors</button>
                    </fieldset>

                    <fieldset class="section">
                        <legend>Terrain Modifiers (%)</legend>
                        <div class="terrain-modifier-grid">
                             <span class="header"></span><span class="header">Production</span><span class="header">Storage</span>
                             <label for="tm_wood_prod">Wood</label>
                             <input type="number" id="tm_wood_prod" step="0.1" value="0.0"><input type="number" id="tm_wood_stor" step="0.1" value="0.0">
                             <label for="tm_iron_prod">Iron</label>
                             <input type="number" id="tm_iron_prod" step="0.1" value="0.0"><input type="number" id="tm_iron_stor" step="0.1" value="0.0">
                             <label for="tm_workers_prod">Workers</label>
                             <input type="number" id="tm_workers_prod" step="0.1" value="0.0"><input type="number" id="tm_workers_stor" step="0.1" value="0.0">
                             <label for="tm_soldiers_prod">Soldiers</label>
                             <input type="number" id="tm_soldiers_prod" step="0.1" value="0.0"><input type="number" id="tm_soldiers_stor" step="0.1" value="0.0">
                        </div>
                         <button id="saveTerrainModifiersButton" style="margin-top: 10px; width: 100%;">Save Terrain Modifiers</button>
                    </fieldset>

                     <fieldset class="section">
                        <legend>Economy Change</legend>
                        <div class="flex-container">
                            <label for="economyMultiplier">Multiplier:</label>
                            <input type="number" id="economyMultiplier" step="0.01" value="1.0" style="flex-grow: 1;">
                            <button id="applyEconomyChangeButton">Apply</button>
                        </div>
                    </fieldset>

                    <button id="upgradeHqButton">Upgrade HQ</button>

                     <fieldset class="section">
                        <legend>Unlock Buildings</legend>
                        <div id="unlockButtonsContainer">
                            <!-- Unlock buttons will be added here -->
                        </div>
                    </fieldset>
                    <div id="tickCounterDisplay" class="tick-counter">Tick: 0</div>
                </div>

                <!-- Right Column -->
                <div class="right-column">
                    <fieldset class="section">
                        <legend>Village Status</legend>
                         <table class="status-table">
                            <thead>
                                <tr><th>Resource</th><th>Amount</th><th>Prod.</th><th>Storage</th><th>P.Mod</th><th>S.Mod</th><th>Goal</th></tr>
                            </thead>
                            <tbody id="statusTableBody">
                                <!-- Rows added by JS -->
                            </tbody>
                        </table>
                        <div id="hqStatusLabel" class="status-info">HQ Level: 1</div>
                        <div id="slotStatusLabel" class="status-info">Empty Build Slot: Yes</div>
                        <div id="goalStatusLabel" class="goal-status-label">Goal Status: -</div>
                    </fieldset>

                    <button id="addBuildingButton">Add Building</button>

                    <div class="flex-container section">
                        <button id="sim1Button">Simulate 1 Tick</button>
                        <button id="sim10Button">Simulate 10 Ticks</button>
                        <button id="sim100Button">Simulate 100 Ticks</button>
                    </div>

                    <fieldset class="section" style="flex-grow: 1; display: flex; flex-direction: column; min-height: 200px;">
                         <legend>Buildings</legend>
                         <button id="sortBuildingsButton" style="margin-bottom: 10px;">Sort Buildings</button>
                         <div id="buildingListContainer" class="building-list-container">
                             <!-- Building buttons added by JS -->
                         </div>
                    </fieldset>
                </div>
            </div>
        </div>

        <!-- Conversion Calculator Tab -->
        <div id="conversionTab" class="tab-content">
            <fieldset class="section">
                 <legend>Add Buildings to List</legend>
                 <div class="flex-container">
                    <label for="convBuildingSelect">Building:</label>
                    <select id="convBuildingSelect"></select>
                    <label for="convLevelInput">Level:</label>
                    <input type="number" id="convLevelInput" min="1" value="1">
                     <label for="convQuantityInput">Quantity:</label>
                    <input type="number" id="convQuantityInput" min="1" value="1">
                    <button id="addConvBuildingButton">Add Building</button>
                </div>
            </fieldset>

            <fieldset class="section">
                 <legend>Buildings List</legend>
                 <ul id="conversionList" class="conversion-list"></ul>
                 <button id="clearConvListButton">Clear List</button>
            </fieldset>

            <button id="calculateCostsButton">Calculate Total Costs</button>
            <div id="totalCostsDisplay" class="total-costs-display">Total Costs: -</div>
            <button id="setGoalButton" style="margin-top: 10px;">Set Goal from Calculated Costs</button>
        </div>

        <!-- Scenario Controls Tab -->
        <div id="scenarioTab" class="tab-content">
             <fieldset class="section">
                <legend>Scenario Controls (Bypasses Resource Checks)</legend>

                <div class="flex-container" style="margin-bottom: 10px;">
                    <label for="scenarioHqLevel">Set HQ Level:</label>
                    <input type="number" id="scenarioHqLevel" min="1">
                    <button id="setHqLevelButton">Set HQ Level [BYPASS]</button>
                </div>

                <div class="flex-container" style="margin-bottom: 10px;">
                     <label for="scenarioBuildingSelect">Add Building:</label>
                     <select id="scenarioBuildingSelect"></select>
                     <label for="scenarioBuildingLevel">Level:</label>
                     <input type="number" id="scenarioBuildingLevel" min="1">
                     <button id="addBuildingScenarioButton">Add Building [BYPASS]</button>
                 </div>

                 <div class="flex-container" style="margin-bottom: 10px;">
                     <label>Set Resources:</label>
                     <label for="scenarioWood">Wood:</label>
                     <input type="number" id="scenarioWood" step="any">
                     <label for="scenarioIron">Iron:</label>
                     <input type="number" id="scenarioIron" step="any">
                     <label for="scenarioWorkers">Workers:</label>
                     <input type="number" id="scenarioWorkers" step="any">
                     <button id="setResourcesScenarioButton">Set Resources [BYPASS]</button>
                 </div>
            </fieldset>
            <p><strong>Warning:</strong> Actions in this tab bypass normal game rules (costs, limits) and directly modify the village state. Use for testing or setting up specific scenarios.</p>
        </div>

        <!-- Add Building Modal Dialog -->
        <dialog id="addBuildingModal">
            <h3>Add Building (Select One)</h3>
            <div id="addBuildingModalGrid" class="modal-grid">
                <!-- Building buttons added by JS -->
            </div>
            <button class="modal-close-button" onclick="document.getElementById('addBuildingModal').close()">Cancel</button>
        </dialog>

        <div id="errorMessage" class="error-message"></div>

    </div> <!-- /container -->

<script>
    // --- Polyfill for String.replaceAll if needed (older browsers) ---
    if (!String.prototype.replaceAll) {
        String.prototype.replaceAll = function(search, replacement) {
            return this.split(search).join(replacement);
        };
    }

    // --- Configuration & Global State ---
    let SCALING_FACTORS = {
        building_wood: 1.5, building_iron: 1.5, building_workers: 1.5,
        hq_wood: 1.5, hq_iron: 1.5, hq_workers: 1.5
    };

    let logMessages = [];
    let tickCounter = 0;
    let goal = { wood: 0, iron: 0, workers: 0, soldiers: 0 }; // Add soldiers to goal tracking
    let appVillage = null; // Holds the main Village instance
    let buildingManager = null; // Holds the BuildingManager instance
    let logProcessor = null; // Holds the LogProcessor instance
    let addBuildingWindowOpen = false; // Track modal state


    // --- Utility Functions ---
    function floor(value) {
        return Math.floor(value);
    }

    function formatResource(value) {
        return value.toFixed(2);
    }

    function logMessage(message, noPrint = false) {
        if (!noPrint) {
            console.log(message);
        }
        logMessages.push(message);
    }

    // Basic parser for the specific "|| {key: val, key2: val2}" format
    // WARNING: Very basic, assumes keys are simple strings and values are numbers.
    // Doesn't handle nested structures, strings with commas/colons, etc.
    function parsePythonDictString(dictStr) {
        const result = {};
        if (!dictStr || !dictStr.startsWith('{') || !dictStr.endsWith('}')) {
            console.error("Invalid format for parsePythonDictString:", dictStr);
            return result; // Return empty on invalid format
        }
        const content = dictStr.slice(1, -1).trim();
        if (!content) return result; // Empty dictionary

        const pairs = content.split(',');
        for (const pair of pairs) {
            const parts = pair.split(':');
            if (parts.length === 2) {
                const key = parts[0].trim().replace(/['"]/g, ''); // Remove quotes from keys
                const valueStr = parts[1].trim();
                const value = parseFloat(valueStr);
                if (!isNaN(value)) {
                    result[key] = value;
                } else {
                     console.warn(`Could not parse value as float in dict string: ${valueStr}`);
                }
            } else {
                 console.warn(`Could not parse pair in dict string: ${pair}`);
            }
        }
        return result;
    }


    // --- Core Classes (Translated from Python) ---

    class Building {
        constructor(name) {
            this.name = name;
            this.costs = {
                wood: { base_cost: 0, starting_level: 0 },
                iron: { base_cost: 0, starting_level: 0 },
                workers: { base_cost: 0, starting_level: 0 },
            };
            this.production = {}; // { resource: { base_rate, rate_increase_per_level } }
            this.storage = null; // { wood, iron, workers, soldiers }
            this.building_modifier_increment = {}; // { resource: increment }
            this.building_storage_modifier_increment = {}; // { resource: increment }
            this.unlocked = false;
        }

        set_cost(resource, base_cost, starting_level) {
            if (resource in this.costs) {
                this.costs[resource].base_cost = base_cost;
                this.costs[resource].starting_level = starting_level;
            } else {
                console.error(`Unknown resource for cost: ${resource} in ${this.name}`);
            }
        }

        set_production(resource, base_rate, rate_increase_per_level) {
            this.production[resource] = { base_rate, rate_increase_per_level };
        }

        set_storage(storageData = { wood: 0, iron: 0, workers: 0, soldiers: 0 }) {
            this.storage = { ...storageData };
        }

        set_building_modifier_increment(resource, increment) {
            this.building_modifier_increment[resource] = increment;
        }

        set_building_storage_modifier_increment(resource, increment) {
            this.building_storage_modifier_increment[resource] = increment;
        }

        unlock() {
            this.unlocked = true;
        }

        calculate_costs(level) {
            const results = {};
            for (const resource in this.costs) {
                const data = this.costs[resource];
                if (level < data.starting_level) {
                    results[resource] = 0;
                } else {
                    const scaling_factor = SCALING_FACTORS[`building_${resource}`] || 1.5;
                    results[resource] = data.base_cost * Math.pow(scaling_factor, level - 1);
                }
            }
            return results;
        }

        calculate_production(level) {
            const results = {};
            for (const resource in this.production) {
                const data = this.production[resource];
                results[resource] = data.base_rate + (data.rate_increase_per_level * (level - 1));
            }
            return results;
        }

        calculate_storage_increase(level) {
            if (this.storage) {
                const base_wood = this.storage.wood || 0;
                const base_iron = this.storage.iron || 0;
                const base_workers = this.storage.workers || 0;
                const base_soldiers = this.storage.soldiers || 0;
                return {
                    wood: base_wood > 0 ? base_wood * level : 0,
                    iron: base_iron > 0 ? base_iron * level : 0,
                    workers: base_workers > 0 ? base_workers * level : 0,
                    soldiers: base_soldiers > 0 ? base_soldiers * level : 0,
                };
            } else {
                return null;
            }
        }

        calculate_upgrade_cost(current_level) {
            if (current_level < 1) {
                console.error("Current level must be at least 1 for upgrade cost calc.");
                return { wood: 0, iron: 0, workers: 0 };
            }
            return this.calculate_costs(current_level + 1);
        }
    }

    class HQ extends Building {
        constructor() {
            super("HQ");
            this.set_cost("wood", 50, 1);
            this.set_cost("iron", 50, 1);
            this.set_cost("workers", 2, 11); // Starts at level 11
            this.unlocked = true;
        }

        calculate_upgrade_cost(current_level) {
            if (current_level < 1) {
                console.error("Current level must be at least 1 for HQ upgrade cost calc.");
                 return { wood: 0, iron: 0, workers: 0 };
            }
            const upgrade_cost = {};
            for (const resource in this.costs) {
                const data = this.costs[resource];
                // Cost applies for upgrading TO the next level (current_level + 1)
                if (current_level + 1 < data.starting_level) {
                    upgrade_cost[resource] = 0;
                } else {
                    // Cost scales based on the level *being completed* (current_level)
                    const scaling_factor = SCALING_FACTORS[`hq_${resource}`] || 1.5;
                     // The cost formula uses level-1 exponent, so for level 1->2 cost, use 1.5^(1-1)=1. For 2->3 use 1.5^(2-1)=1.5.
                    upgrade_cost[resource] = data.base_cost * Math.pow(scaling_factor, current_level - 1);
                }
            }
            return upgrade_cost;
        }
    }

    class BuildingManager {
        constructor() {
            this.buildings = {}; // { name: BuildingInstance }
        }

        register_building(building_instance) {
            if (!(building_instance instanceof Building)) {
                throw new TypeError("Can only register instances of Building subclasses.");
            }
            this.buildings[building_instance.name] = building_instance;
        }

        get_building(name) {
            return this.buildings[name] || null;
        }

        get_all_buildings() {
            return Object.values(this.buildings);
        }

        load_and_register_definitions(buildingDefs) {
            this.buildings = {}; // Clear existing
             if (typeof buildingDefs?.get_building_definitions !== 'function') {
                 console.error("Building definitions object missing 'get_building_definitions' function.");
                 return false;
             }
            try {
                const buildingClasses = buildingDefs.get_building_definitions();
                for (const BuildingClass of buildingClasses) {
                    const instance = new BuildingClass();
                    this.register_building(instance);
                }
                console.log(`Successfully loaded and registered ${buildingClasses.length} buildings.`);
                return true;
            } catch (e) {
                console.error("Error loading or registering building definitions:", e);
                return false;
            }
        }
    }

    class Village {
        static BASE_STORAGE = {
            wood: 140, iron: 140, workers: 50, soldiers: 50,
        };

        constructor() {
            this.hq = new HQ();
            this.hq_level = 1;
            this.buildings = []; // [ { building: BuildingInstance, level: number } ]
            this.resources = {
                wood: Village.BASE_STORAGE.wood, iron: Village.BASE_STORAGE.iron,
                workers: 0, soldiers: 0,
            };
            // Modifiers are decimals (e.g., 0.1 for 10%)
            this.terrain_modifiers = { wood: 0.0, iron: 0.0, workers: 0.0, soldiers: 0.0 };
            this.building_modifiers = { wood: 0.0, iron: 0.0, workers: 0.0, soldiers: 0.0 };
            this.terrain_storage_modifiers = { wood: 0.0, iron: 0.0, workers: 0.0, soldiers: 0.0 };
            this.building_storage_modifiers = { wood: 0.0, iron: 0.0, workers: 0.0, soldiers: 0.0 };
        }

        set_terrain_modifier(resource, modifier) {
            if (resource in this.terrain_modifiers) {
                this.terrain_modifiers[resource] = modifier;
            } else {
                console.error(`Unknown resource for terrain modifier: ${resource}`);
            }
        }

         set_terrain_storage_modifier(resource, modifier) {
            if (resource in this.terrain_storage_modifiers) {
                this.terrain_storage_modifiers[resource] = modifier;
            } else {
                console.error(`Unknown resource for terrain storage modifier: ${resource}`);
            }
        }

        // Note: Building modifiers are calculated, not set directly usually
        set_building_modifier(resource, modifier) { /* Usually calculated */ }
        set_building_storage_modifier(resource, modifier) { /* Usually calculated */ }


        get_true_modifier(resource) {
            if (resource in this.terrain_modifiers && resource in this.building_modifiers) {
                this.calculate_building_modifiers(); // Recalculate before getting
                const base = 1.0;
                const terrain = this.terrain_modifiers[resource] || 0;
                const building = this.building_modifiers[resource] || 0;
                return Math.max(0.0, base + terrain + building);
            }
            return 1.0;
        }

        get_true_storage_modifier(resource) {
            if (resource in this.terrain_storage_modifiers && resource in this.building_storage_modifiers) {
                this.calculate_building_storage_modifiers(); // Recalculate before getting
                const base = 1.0;
                const terrain = this.terrain_storage_modifiers[resource] || 0;
                const building = this.building_storage_modifiers[resource] || 0;
                return Math.max(0.0, base + terrain + building);
            }
            return 1.0;
        }

        calculate_building_modifiers() {
            this.building_modifiers = { wood: 0.0, iron: 0.0, workers: 0.0, soldiers: 0.0 };
            for (const building_data of this.buildings) {
                const building = building_data.building;
                const level = building_data.level;
                for (const resource in building.building_modifier_increment) {
                    const increment = building.building_modifier_increment[resource];
                    if (resource in this.building_modifiers) {
                        this.building_modifiers[resource] += increment * level;
                    }
                }
            }
        }

        calculate_building_storage_modifiers() {
            this.building_storage_modifiers = { wood: 0.0, iron: 0.0, workers: 0.0, soldiers: 0.0 };
             for (const building_data of this.buildings) {
                const building = building_data.building;
                const level = building_data.level;
                 for (const resource in building.building_storage_modifier_increment) {
                     const increment = building.building_storage_modifier_increment[resource];
                     if (resource in this.building_storage_modifiers) {
                         this.building_storage_modifiers[resource] += increment * level;
                    }
                }
            }
        }

        add_building(building_instance, level = 1) {
            if (!(building_instance instanceof Building)) {
                console.error("Attempted to add non-Building object:", building_instance);
                return false;
            }
            if (this.buildings.length >= this.hq_level) {
                console.warn("Building limit reached.");
                alert("Building limit reached. Cannot add more buildings until HQ is upgraded.");
                return false;
            }
            if (!building_instance.unlocked) {
                console.warn(`Building '${building_instance.name}' is locked.`);
                 alert(`Building '${building_instance.name}' is locked.`);
                return false;
            }

            const building_cost = building_instance.calculate_costs(level);
            let can_afford = true;
            const missing_resources = [];
            for (const resource in building_cost) {
                const cost = building_cost[resource];
                if ((this.resources[resource] || 0) < cost) {
                    can_afford = false;
                    missing_resources.push(`${resource}: ${floor(cost - (this.resources[resource] || 0))} needed`);
                }
            }

            if (!can_afford) {
                console.warn(`Cannot afford ${building_instance.name} (Level ${level}). Missing: ${missing_resources.join(', ')}`);
                 alert(`Cannot afford ${building_instance.name} (Level ${level}).\nMissing: ${missing_resources.join(', ')}`);
                return false;
            }

            for (const resource in building_cost) {
                this.resources[resource] -= building_cost[resource];
            }
            this.buildings.push({ building: building_instance, level: level });
            this.calculate_building_modifiers();
            this.calculate_building_storage_modifiers();
            return true;
        }

        can_upgrade_building(building_data) {
            const building = building_data.building;
            const current_level = building_data.level;
            const upgrade_cost = building.calculate_upgrade_cost(current_level);
            for (const resource in upgrade_cost) {
                const cost = upgrade_cost[resource];
                if ((this.resources[resource] || 0) < cost) {
                    return false;
                }
            }
            return true;
        }

        upgrade_building(building_data) {
            const building = building_data.building;
            const current_level = building_data.level;

            if (!this.can_upgrade_building(building_data)) {
                 // Display detailed cost failure message
                 const upgrade_cost = building.calculate_upgrade_cost(current_level);
                 const cost_str = [];
                 const missing_str = [];
                 for (const res in upgrade_cost) {
                     const cost = upgrade_cost[res];
                     if (cost > 0) {
                         const current = this.resources[res] || 0;
                         cost_str.push(`${res.charAt(0).toUpperCase() + res.slice(1)}: ${floor(cost)}`);
                         if (current < cost) {
                             missing_str.push(`${res}: ${floor(cost - current)}`);
                         }
                     }
                 }
                 let msg = `Cannot afford upgrade for ${building.name} (Lv.${current_level}).\n`;
                 msg += `Cost: ${cost_str.join(', ')}\n`;
                 if (missing_str.length > 0) {
                     msg += `Missing: ${missing_str.join(', ')}`;
                 }
                 alert(msg);
                 return false;
             }

            const upgrade_cost = building.calculate_upgrade_cost(current_level);
            for (const resource in upgrade_cost) {
                this.resources[resource] -= upgrade_cost[resource];
            }
            building_data.level += 1; // Upgrade level IN PLACE
            this.calculate_building_modifiers();
            this.calculate_building_storage_modifiers();
            return true;
        }

        delete_building(building_name, level) {
            let found_index = -1;
            for (let i = 0; i < this.buildings.length; i++) {
                if (this.buildings[i].building.name === building_name && this.buildings[i].level === level) {
                    found_index = i;
                    break;
                }
            }
            if (found_index !== -1) {
                this.buildings.splice(found_index, 1); // Remove the building
                this.calculate_building_modifiers();
                this.calculate_building_storage_modifiers();
                return true;
            } else {
                console.warn(`Could not find ${building_name} (Level ${level}) to delete.`);
                return false;
            }
        }

        calculate_total_production() {
            const total_production = { wood: 1.0, iron: 0.0, workers: 0.0, soldiers: 0.0 }; // Base wood prod
            this.calculate_building_modifiers(); // Recalculate first

            for (const building_data of this.buildings) {
                const building = building_data.building;
                const level = building_data.level;
                const production = building.calculate_production(level);
                for (const resource in production) {
                     const base_amount = production[resource];
                     if (resource in total_production) {
                        const true_modifier = this.get_true_modifier(resource);
                        total_production[resource] += base_amount * true_modifier;
                    }
                }
            }
            // Ensure production is not negative
            for (const resource in total_production) {
                total_production[resource] = Math.max(0.0, total_production[resource]);
            }
            return total_production;
        }

        calculate_total_storage() {
            const total_storage = { ...Village.BASE_STORAGE };
            this.calculate_building_storage_modifiers(); // Recalculate first

            for (const building_data of this.buildings) {
                const building = building_data.building;
                const level = building_data.level;
                const storage_increase = building.calculate_storage_increase(level);
                if (storage_increase) {
                    for (const resource in storage_increase) {
                         if (resource in total_storage) {
                            total_storage[resource] += storage_increase[resource];
                        }
                    }
                }
            }
             // Apply multipliers
            for (const resource in total_storage) {
                 const true_storage_multiplier = this.get_true_storage_modifier(resource);
                 total_storage[resource] *= true_storage_multiplier;
                 total_storage[resource] = Math.max(0.0, total_storage[resource]); // Ensure non-negative
            }
            return total_storage;
        }

        simulate_ticks(num_ticks) {
            if (num_ticks <= 0) return;

            const total_production = this.calculate_total_production();
            const total_storage = this.calculate_total_storage();

            for (const resource in total_production) {
                 if (resource in this.resources && resource in total_storage) {
                    const production_rate = total_production[resource];
                    const current_amount = this.resources[resource];
                    const storage_capacity = total_storage[resource];
                    const produced = production_rate * num_ticks;
                    const new_amount = current_amount + produced;
                    this.resources[resource] = Math.min(new_amount, storage_capacity); // Cap at storage
                }
            }
        }

        can_upgrade_hq() {
            if (this.hq_level < 1) return false;
            const upgrade_cost = this.hq.calculate_upgrade_cost(this.hq_level);
            for (const resource in upgrade_cost) {
                const cost = upgrade_cost[resource];
                 if ((this.resources[resource] || 0) < cost) {
                    return false;
                }
            }
            return true;
        }

        upgrade_hq() {
             if (!this.can_upgrade_hq()) {
                 // Display detailed cost failure message
                 const upgrade_cost = this.hq.calculate_upgrade_cost(this.hq_level);
                 const cost_str = [];
                 const missing_str = [];
                 for (const res in upgrade_cost) {
                     const cost = upgrade_cost[res];
                     if (cost > 0) {
                         const current = this.resources[res] || 0;
                         cost_str.push(`${res.charAt(0).toUpperCase() + res.slice(1)}: ${floor(cost)}`);
                         if (current < cost) {
                             missing_str.push(`${res}: ${floor(cost - current)}`);
                         }
                     }
                 }
                 let msg = "Cannot afford HQ upgrade.\n";
                 msg += `Cost: ${cost_str.join(', ')}\n`;
                 if (missing_str.length > 0) {
                     msg += `Missing: ${missing_str.join(', ')}`;
                 }
                 alert(msg);
                 return false;
             }

            const upgrade_cost = this.hq.calculate_upgrade_cost(this.hq_level);
            for (const resource in upgrade_cost) {
                this.resources[resource] -= upgrade_cost[resource];
            }
            this.hq_level += 1;
            return true;
        }
    }

     // --- Building Definitions (Translated) ---
    class Storehouse extends Building {
        constructor() { super("Storehouse"); this.set_cost("wood", 80, 1); this.set_cost("iron", 20, 1); this.set_cost("workers", 1, 4); this.set_storage({ wood: 1000, iron: 1000 }); this.unlocked = true; }
    }
    class WoodcuttersHut extends Building {
        constructor() { super("Woodcutter's Hut"); this.set_cost("wood", 40, 1); this.set_cost("workers", 0.5, 8); this.set_production("wood", 0.5, 0.5); this.unlocked = true; }
    }
    class IronMine extends Building {
        constructor() { super("Iron Mine"); this.set_cost("wood", 40, 1); this.set_cost("iron", 10, 2); this.set_cost("workers", 0.5, 8); this.set_production("iron", 0.5, 0.5); this.unlocked = true; }
    }
    class Tavern extends Building {
        constructor() { super("Tavern"); this.set_cost("wood", 150, 1); this.set_cost("iron", 100, 1); this.set_cost("workers", 10, 4); this.set_production("workers", 0.1, 0.1); this.unlocked = true; }
    }
    class TrainingCenter extends Building {
        constructor() { super("Training Center"); this.set_cost("wood", 100, 1); this.set_cost("iron", 150, 1); this.set_cost("workers", 8, 4); this.set_production("soldiers", 0.05, 0.05); this.unlocked = true; }
    }
    class House extends Building {
        constructor() { super("House"); this.set_cost("wood", 500, 1); this.set_cost("iron", 400, 1); this.set_cost("workers", 10, 4); this.set_storage({ workers: 500 }); this.unlocked = true; }
    }
    class Barracks extends Building {
        constructor() { super("Barracks"); this.set_cost("wood", 500, 1); this.set_cost("iron", 500, 1); this.set_cost("workers", 50, 3); this.set_storage({ soldiers: 500 }); this.unlocked = true; }
    }
    class Sawmill extends Building {
        constructor() { super("Sawmill"); this.set_cost("wood", 150, 1); this.set_cost("iron", 37, 1); this.set_cost("workers", 2, 1); this.set_production("wood", 0.5, 0.5); this.set_building_modifier_increment("wood", 0.02); this.set_storage({ wood: 200 }); this.unlocked = false; }
    }
    class Furnace extends Building {
        constructor() { super("Furnace"); this.set_cost("wood", 150, 1); this.set_cost("iron", 37, 1); this.set_cost("workers", 2, 1); this.set_production("iron", 0.5, 0.5); this.set_building_modifier_increment("iron", 0.02); this.set_storage({ iron: 200 }); this.unlocked = false; }
    }
    class Townhall extends Building {
        constructor() { super("Townhall"); this.set_cost("wood", 1000, 1); this.set_cost("iron", 600, 1); this.set_cost("workers", 15, 1); this.set_building_modifier_increment("wood", 0.05); this.set_building_modifier_increment("iron", 0.05); this.set_building_storage_modifier_increment("wood", 0.06); this.set_building_storage_modifier_increment("iron", 0.06); this.unlocked = false; }
    }
    class MercenaryOffice extends Building {
        constructor() { super("Mercenary Office"); this.set_cost("wood", 400, 1); this.set_cost("iron", 400, 1); this.set_cost("workers", 15, 1); this.set_production("soldiers", 0.05, 0.05); this.set_production("workers", 0.1, 0.1); this.set_building_modifier_increment("wood", -0.03); this.set_building_modifier_increment("iron", -0.03); this.unlocked = false; }
    }
    class CommandCenter extends Building {
        constructor() { super("Command Center"); this.set_cost("wood", 500, 1); this.set_cost("iron", 1000, 1); this.set_cost("workers", 15, 1); this.unlocked = false; }
    }
    class Arena extends Building {
        constructor() { super("Arena"); this.set_cost("wood", 500, 1); this.set_cost("iron", 1000, 1); this.set_cost("workers", 15, 1); this.set_building_modifier_increment("soldiers", 0.03); this.unlocked = false; }
    }
    class SpecialUnitTrainingCenter extends Building {
        constructor() { super("Special Unit Training Center"); this.set_cost("wood", 500, 1); this.set_cost("iron", 1000, 1); this.set_cost("workers", 5, 1); this.unlocked = false; }
    }

    const BUILDING_DEFINITIONS = {
        get_building_definitions: () => [
            Storehouse, WoodcuttersHut, IronMine, Tavern, TrainingCenter, House, Barracks,
            Sawmill, Furnace, Townhall, MercenaryOffice, CommandCenter, Arena, SpecialUnitTrainingCenter
        ],

        get_initial_village_state: () => {
            const initial_hq_level = 4;
            const initial_resources = {
                wood: 580, iron: 470, workers: 0, soldiers: 0,
            };
            const initial_buildings = [
                ["Storehouse", 1], ["Woodcutter's Hut", 2], ["Iron Mine", 1], ["Training Center", 1],
            ];
            return { initial_hq_level, initial_resources, initial_buildings };
        }
    };

    // --- Build Assistant Function ---
    function findCumulativeCost(buildingName, level) {
        const result = { wood: 0, iron: 0, workers: 0 };
        if (level < 1) {
            console.warn(`findCumulativeCost called with level ${level}. Returning zero cost.`);
            return result;
        }

        const building = buildingManager.get_building(buildingName);
        if (!building) {
            console.error(`Building ${buildingName} not found in findCumulativeCost. Returning zero cost.`);
            return result;
        }

        for (let lvl = 1; lvl <= level; lvl++) {
            const costs = building.calculate_costs(lvl);
            for (const resource in costs) {
                if (resource in result) {
                    result[resource] += costs[resource];
                } else {
                    console.warn(`Unexpected resource '${resource}' in cost calculation for ${buildingName}.`);
                    result[resource] = costs[resource];
                }
            }
        }
        return result;
    }

    // --- Log Processor Class ---
    class LogProcessor {
        constructor() {
            this.village = null; // Will be set during processing
            // Tick counter is managed globally in the UI in this version
        }

        createInitialVillage() {
            try {
                 const { initial_hq_level, initial_resources, initial_buildings } = BUILDING_DEFINITIONS.get_initial_village_state();
                 const village = new Village();
                 village.hq_level = initial_hq_level;
                 // Update resources *before* adding buildings, assuming initial resources *already account* for initial building costs.
                 Object.assign(village.resources, initial_resources);

                 for (const [name, level] of initial_buildings) {
                     const buildingInstance = buildingManager.get_building(name);
                     if (!buildingInstance) {
                         throw new Error(`Initial building '${name}' not found. Check definitions.`);
                     }
                     // Bypass resource check for initial buildings, assume they are pre-placed
                     if (village.buildings.length < village.hq_level) {
                         village.buildings.push({ building: buildingInstance, level: level });
                     } else {
                         console.warn(`Initial building limit (${village.hq_level}) reached, could not add ${name} (Level ${level}).`);
                     }
                 }
                 village.calculate_building_modifiers();
                 village.calculate_building_storage_modifiers();
                 return village;
             } catch (e) {
                 console.error("Error creating initial village:", e);
                 throw new Error(`Failed to create initial village state: ${e.message}`);
             }
        }

        initializeBaseVillage() {
             try {
                this.village = this.createInitialVillage();
                return null; // Success
             } catch (e) {
                console.error("ERROR in LogProcessor.initializeBaseVillage:", e);
                return `Error during base village creation: ${e.message}`;
             }
        }

        processLogContent(logContent, uiLogCallback = console.log) {
            let currentVillage = null;
            let currentTick = 0;
            let initError = null;

            try {
                initError = this.initializeBaseVillage(); // Sets this.village
                if (initError) {
                    return { village: null, tickCount: 0, error: `Log processing failed during initialization: ${initError}` };
                }
                currentVillage = this.village; // Use the initialized village
                uiLogCallback("Created base set. [INITIALIZE]"); // Log initial state

                const lines = logContent.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    const lineNum = i + 1;
                    let line = lines[i].trim();
                    if (!line) continue;

                     // Skip the first initialize message if present
                    if (line.includes("Created base set. [INITIALIZE]")) {
                         if (lineNum === 1) continue;
                         else console.warn(`Found '[INITIALIZE]' message on line ${lineNum}, processing anyway.`);
                    }

                    if (line.startsWith("Tick")) {
                        try {
                             const firstColonIndex = line.indexOf(':');
                             if (firstColonIndex === -1) {
                                 console.warn(`Skipping log line ${lineNum} without colon: '${line}'`);
                                 continue;
                             }

                            const tickPart = line.substring(0, firstColonIndex).trim();
                            const actionPart = line.substring(firstColonIndex + 1).trim();

                            const tickMatch = tickPart.match(/Tick\s+(\d+)$/);
                             if (!tickMatch) {
                                return { village: null, tickCount: currentTick, error: `Error parsing tick number on line ${lineNum}: '${tickPart}'. Line: '${line}'` };
                             }
                            const logTick = parseInt(tickMatch[1], 10);

                             // Simulate ticks to catch up
                             if (logTick > currentTick) {
                                const ticksToSimulate = logTick - currentTick;
                                currentVillage.simulate_ticks(ticksToSimulate);
                                currentTick = logTick;
                             }

                            // Log the action being processed
                            uiLogCallback(line); // Log the original line via callback

                            // Process the action
                             const error = this.processLogEntry(actionPart);
                             if (error) {
                                return { village: null, tickCount: currentTick, error: `Error processing log entry on line ${lineNum} (Tick ${currentTick}): ${error}. Line: '${line}'` };
                             }

                        } catch (e) {
                            console.error("Error parsing log line:", e);
                             return { village: null, tickCount: currentTick, error: `Error parsing log line ${lineNum}: ${e.message}. Line: '${line}'` };
                        }
                    } else {
                        console.warn(`Skipping non-tick log line ${lineNum}: '${line}'`);
                    }
                }

                // --- Success ---
                return { village: currentVillage, tickCount: currentTick, error: null };

            } catch (e) {
                console.error("Unexpected error processing log content:", e);
                return { village: null, tickCount: currentTick, error: `Unexpected error processing log file: ${e.message}` };
            }
        }

        // Processes a list of log message strings (for revert)
         processLogMessages(logMessagesList, uiLogCallback = () => {}) {
             let currentVillage = null;
             let currentTick = 0;
             let initError = null;

             try {
                 initError = this.initializeBaseVillage(); // Sets this.village
                 if (initError) {
                     return { village: null, tickCount: 0, error: `Processing failed during initialization: ${initError}` };
                 }
                 currentVillage = this.village;
                 // uiLogCallback("[Initialize Base Village For Revert/Process]"); // Don't log this

                 for (let i = 0; i < logMessagesList.length; i++) {
                    const lineNum = i + 1;
                    let line = logMessagesList[i].trim();
                    if (!line) continue;

                    if (line.includes("Created base set. [INITIALIZE]")) {
                         if (lineNum === 1) continue;
                         else console.warn(`Found '[INITIALIZE]' message on line ${lineNum}, processing anyway.`);
                    }

                    if (line.startsWith("Tick")) {
                        try {
                             const firstColonIndex = line.indexOf(':');
                             if (firstColonIndex === -1) continue; // Skip malformed

                            const tickPart = line.substring(0, firstColonIndex).trim();
                            const actionPart = line.substring(firstColonIndex + 1).trim();

                            const tickMatch = tickPart.match(/Tick\s+(\d+)$/);
                             if (!tickMatch) continue; // Skip malformed
                             const logTick = parseInt(tickMatch[1], 10);

                             if (logTick > currentTick) {
                                const ticksToSimulate = logTick - currentTick;
                                currentVillage.simulate_ticks(ticksToSimulate);
                                currentTick = logTick;
                             }

                             // Don't log via UI callback during internal processing like revert
                             // uiLogCallback(line);

                             const error = this.processLogEntry(actionPart);
                             if (error) {
                                return { village: null, tickCount: currentTick, error: `Error processing message list on line ${lineNum} (Tick ${currentTick}): ${error}. Line: '${line}'` };
                             }
                        } catch (e) {
                             console.error("Error parsing message list line:", e);
                             return { village: null, tickCount: currentTick, error: `Error parsing message list line ${lineNum}: ${e.message}. Line: '${line}'` };
                        }
                     } else {
                         console.warn(`Skipping non-tick message line ${lineNum}: '${line}'`);
                     }
                 }
                 // --- Success ---
                 return { village: currentVillage, tickCount: currentTick, error: null };
             } catch (e) {
                 console.error("Unexpected error processing message list:", e);
                 return { village: null, tickCount: currentTick, error: `Unexpected error processing message list: ${e.message}` };
             }
         }


        processLogEntry(actionPart) {
            if (!actionPart || !this.village) return null; // Ignore empty or if village not init

            const actionLower = actionPart.toLowerCase();

             try {
                 if (actionLower.startsWith("updated scaling factors to ||")) {
                     return this.processScalingFactors(actionPart);
                 } else if (actionLower.startsWith("updated terrain modifiers to ||")) {
                     return this.processTerrainModifiers(actionPart);
                 } else if (actionLower.includes("applied economy change multiplier")) { // More flexible match
                     return this.processEconomyChange(actionPart);
                 } else if (actionLower.startsWith("unlocked")) {
                     return this.processUnlockBuilding(actionPart);
                 } else if (actionLower.startsWith("added")) {
                     return this.processAddBuilding(actionPart);
                 } else if (actionLower.startsWith("upgraded hq to level")) {
                     return this.processUpgradeHq(actionPart);
                 } else if (actionLower.startsWith("set hq to level")) { // Handle bypass
                      return this.processSetHqLevelBypass(actionPart);
                 } else if (actionLower.startsWith("upgraded")) { // Must come after HQ upgrade
                     return this.processUpgradeBuilding(actionPart);
                 } else if (actionLower.startsWith("deleted")) {
                     return this.processDeleteBuilding(actionPart);
                 } else if (actionLower.startsWith("set resources to")) {
                     return this.processSetResources(actionPart);
                 } else {
                     console.warn(`Unknown action type in log entry: '${actionPart}'`);
                     return null; // Continue processing log
                     // return `Unknown log entry action: ${actionPart}`; // Stop processing log
                 }
             } catch (e) {
                 console.error(`ERROR processing action: ${actionPart}`, e);
                 return `Error during action processing '${actionPart.substring(0, 30)}...': ${e.message}`;
             }
        }

        processSetResources(actionPart) {
             const bypass = actionPart.includes("[BYPASS]");
             const cleanActionPart = actionPart.replace(" [BYPASS]", "").trim();
             try {
                // Example: "Set resources to wood=500.00, iron=450.00, workers=10.00"
                const resourcesStr = cleanActionPart.split("Set resources to")[1]?.trim();
                if (!resourcesStr) return "Malformed 'set resources' entry (missing data)";

                const resources = {};
                const pairs = resourcesStr.split(",");
                for (const pair of pairs) {
                    const keyVal = pair.trim().split("=");
                    if (keyVal.length === 2) {
                         const key = keyVal[0].trim().toLowerCase();
                         const value = parseFloat(keyVal[1].trim());
                         if (!isNaN(value)) {
                            if (key in this.village.resources) {
                                resources[key] = value;
                            } else {
                                 console.warn(`Unknown resource '${key}' in 'set resources' log entry.`);
                            }
                         } else {
                             console.warn(`Invalid value '${keyVal[1]}' for resource '${key}' in 'set resources' entry.`);
                         }
                    } else {
                         console.warn(`Malformed pair '${pair}' in 'set resources' log entry.`);
                    }
                }

                // Set the resources directly
                for (const resource in resources) {
                    this.village.resources[resource] = resources[resource];
                }
                return null; // Success
             } catch (e) {
                console.error("Error parsing 'set resources':", e);
                return `Error parsing 'set resources' entry: ${e.message}`;
             }
        }

        processScalingFactors(actionPart) {
            try {
                const parts = actionPart.split("||");
                if (parts.length < 2) return "Malformed scaling factors entry: '||' separator not found.";
                const scalingFactorsStr = parts[1].trim();

                // Use custom parser instead of JSON.parse or eval
                const scalingFactorsData = parsePythonDictString(scalingFactorsStr);

                if (Object.keys(scalingFactorsData).length === 0 && scalingFactorsStr !== '{}') {
                     // Parsing likely failed if the string wasn't empty but result is
                    return `Error parsing scaling factors string: '${scalingFactorsStr}'`;
                }


                let changed = false;
                for (const key in scalingFactorsData) {
                    if (key in SCALING_FACTORS) {
                        SCALING_FACTORS[key] = scalingFactorsData[key];
                        changed = true;
                    } else {
                        console.warn(`Unknown scaling factor key '${key}' in log.`);
                    }
                }
                return null; // Success
            } catch (e) {
                console.error("Error processing scaling factors:", e);
                return `Error processing scaling factors: ${e.message}`;
            }
        }

         processTerrainModifiers(actionPart) {
             try {
                 const parts = actionPart.split("||");
                 if (parts.length < 2) return "Malformed terrain modifiers entry: '||' separator not found.";
                 const modifiersStr = parts[1].trim();
                 const modifiersData = parsePythonDictString(modifiersStr);

                if (Object.keys(modifiersData).length === 0 && modifiersStr !== '{}') {
                    return `Error parsing terrain modifiers string: '${modifiersStr}'`;
                 }


                 for (const key in modifiersData) {
                    const value = modifiersData[key];
                    const keyParts = key.split("_"); // e.g., "wood_production"
                     if (keyParts.length === 2) {
                         const resource = keyParts[0].toLowerCase();
                         const modifierType = keyParts[1].toLowerCase();

                         if (modifierType === "production") {
                             if (resource in this.village.terrain_modifiers) {
                                 this.village.set_terrain_modifier(resource, value);
                             } else {
                                 console.warn(`Unknown resource '${resource}' for terrain production modifier.`);
                             }
                         } else if (modifierType === "storage") {
                              if (resource in this.village.terrain_storage_modifiers) {
                                 this.village.set_terrain_storage_modifier(resource, value);
                             } else {
                                 console.warn(`Unknown resource '${resource}' for terrain storage modifier.`);
                             }
                         } else {
                             console.warn(`Unknown modifier type '${modifierType}' in terrain log key '${key}'.`);
                         }
                     } else {
                         console.warn(`Malformed terrain modifier key '${key}' in log.`);
                     }
                 }
                 return null; // Success
             } catch (e) {
                 console.error("Error processing terrain modifiers:", e);
                 return `Error parsing terrain modifiers: ${e.message}`;
             }
         }

         processEconomyChange(actionPart) {
             try {
                // Example: "Applied economy change with multiplier 2.0. New scaling factors: || {...}"
                 const multiplierMatch = actionPart.match(/multiplier\s+([\d.]+)/i);
                 if (!multiplierMatch || multiplierMatch.length < 2) {
                    return "Could not find multiplier value in economy change log.";
                 }
                 const multiplier = parseFloat(multiplierMatch[1]);
                 if (isNaN(multiplier) || multiplier <= 0) {
                     return `Invalid multiplier value: ${multiplierMatch[1]}. Must be positive number.`;
                 }

                 // Apply the economy change to global SCALING_FACTORS
                 for (const key in SCALING_FACTORS) {
                     SCALING_FACTORS[key] *= multiplier;
                 }
                 // The log also contains the *new* factors after multiplication.
                 // We could optionally re-parse them here to ensure consistency,
                 // but for simulation, just applying the multiplier is usually sufficient.
                 // If needed, call processScalingFactors on the part after '||' here.

                 return null; // Success
             } catch (e) {
                 console.error("Error processing economy change:", e);
                 return `Error parsing economy change multiplier: ${e.message}`;
             }
         }

         processUnlockBuilding(actionPart) {
             try {
                 // Example: "Unlocked Sawmill"
                 const buildingName = actionPart.split("Unlocked")[1]?.trim();
                 if (!buildingName) return "Error parsing 'unlocked' entry: building name not found.";

                 const building = buildingManager.get_building(buildingName);
                 if (building) {
                     building.unlock(); // Unlock the definition
                     return null; // Success
                 } else {
                     return `Building '${buildingName}' not found for unlock.`;
                 }
             } catch (e) {
                 console.error("Error processing unlock:", e);
                 return `Error parsing 'unlocked' entry: ${e.message}`;
             }
         }

         processAddBuilding(actionPart) {
             const bypass = actionPart.includes("[BYPASS]");
             const cleanActionPart = actionPart.replace(" [BYPASS]", "").trim();
             try {
                 // Example: "Added Woodcutter's Hut (Level 1)"
                 const parts = cleanActionPart.split("Added")[1]?.trim().split("(Level");
                 if (!parts || parts.length < 2) return "Malformed 'add building' entry.";

                 const buildingName = parts[0].trim();
                 const levelMatch = parts[1].match(/(\d+)\)/);
                 if (!levelMatch || levelMatch.length < 2) return "Malformed 'add building' entry (level not found).";
                 const level = parseInt(levelMatch[1], 10);

                 const building = buildingManager.get_building(buildingName);
                 if (!building) {
                     return `Building '${buildingName}' not found to add.`;
                 }

                 if (bypass) {
                     // Directly add to list, bypassing resource checks and village method logic
                     if (this.village.buildings.length < this.village.hq_level) {
                         this.village.buildings.push({ building: building, level: level });
                         // Manually recalculate modifiers after direct add
                         this.village.calculate_building_modifiers();
                         this.village.calculate_building_storage_modifiers();
                         return null; // Success
                     } else {
                         return `Failed to add '${buildingName}' [BYPASS] (building limit reached)`;
                     }
                 } else {
                     // Use the village's add method (handles resource deduction etc.)
                     // Note: The 'add_building' method in JS village assumes resources *were available*
                     // at the time the log was created. It *will* deduct costs now.
                     // If current resources are insufficient, it will fail. This is correct behavior for replay.
                     if (this.village.add_building(building, level)) {
                         return null; // Success
                     } else {
                         // Construct a more informative error message if possible
                         const cost = building.calculate_costs(level);
                         const missing = [];
                         for (const r in cost) {
                             if ((this.village.resources[r] || 0) < cost[r]) {
                                 missing.push(`${r}: ${floor(cost[r] - (this.village.resources[r] || 0))}`);
                             }
                         }
                         const limit_reached = this.village.buildings.length >= this.village.hq_level;
                         const reason = limit_reached ? "building limit reached" : (missing.length > 0 ? `insufficient resources (missing ${missing.join(', ')})` : "unknown reason");
                         // Return error because replay failed under current state
                         return `Failed to replay add '${buildingName}' (Level ${level}) (${reason})`;
                     }
                 }
             } catch (e) {
                 console.error("Error parsing 'add building':", e);
                 return `Error parsing 'add building' entry: ${e.message}`;
             }
         }

         processUpgradeHq(actionPart) {
              // No bypass check here, regular upgrades imply resources were spent
             try {
                 // Example: "Upgraded HQ to level 5"
                 const levelMatch = actionPart.match(/level\s+(\d+)$/);
                 if (!levelMatch || levelMatch.length < 2) return "Malformed 'upgrade HQ' entry (level not found).";
                 const targetLevel = parseInt(levelMatch[1], 10);
                 const previousLevel = this.village.hq_level;

                  if (targetLevel !== previousLevel + 1) {
                      console.warn(`HQ upgrade log jumps from ${previousLevel} to ${targetLevel}.`);
                      // Attempt the upgrade anyway, assuming resources were sufficient at the time
                  }

                 // Simulate the upgrade using the village method (deducts resources)
                  // This will fail if current resources are insufficient, which is correct for replay.
                 if (this.village.upgrade_hq()) {
                     // Check if the resulting level matches the log
                     if (this.village.hq_level !== targetLevel) {
                         console.warn(`HQ level after upgrade (${this.village.hq_level}) doesn't match log (${targetLevel}). Forcing level.`);
                         // Force level to match log for consistency during replay
                         this.village.hq_level = targetLevel;
                     }
                     return null; // Success
                 } else {
                      // Get cost for the intended upgrade (from prev level)
                      const cost = this.village.hq.calculate_upgrade_cost(previousLevel);
                      const missing = [];
                      for (const r in cost) {
                          if ((this.village.resources[r] || 0) < cost[r]) {
                              missing.push(`${r}: ${floor(cost[r] - (this.village.resources[r] || 0))}`);
                          }
                      }
                      const reason = missing.length > 0 ? `insufficient resources (missing ${missing.join(', ')})` : "unknown reason (upgrade_hq returned false)";
                      return `Failed to replay 'upgrade HQ to ${targetLevel}' (${reason})`;
                 }
             } catch (e) {
                 console.error("Error parsing 'upgrade HQ':", e);
                 return `Error parsing 'upgrade HQ' entry: ${e.message}`;
             }
         }

        processSetHqLevelBypass(actionPart) {
             try {
                 // Example: "Set HQ to level 18 [BYPASS]"
                 const levelMatch = actionPart.replace(" [BYPASS]", "").match(/level\s+(\d+)$/);
                 if (!levelMatch || levelMatch.length < 2) return "Malformed 'set HQ level [BYPASS]' entry.";
                 const level = parseInt(levelMatch[1], 10);
                 if (level < 1) return "HQ level must be at least 1.";

                 this.village.hq_level = level; // Directly set the level
                 return null; // Success
             } catch (e) {
                 console.error("Error parsing 'set HQ level [BYPASS]':", e);
                 return `Error parsing 'set HQ level [BYPASS]' entry: ${e.message}`;
             }
        }


        processUpgradeBuilding(actionPart) {
              // No bypass check here, regular upgrades imply resources were spent
             try {
                 // Example: "Upgraded Woodcutter's Hut to level 2"
                 const parts = actionPart.split("Upgraded")[1]?.trim().split("to level");
                 if (!parts || parts.length < 2) return "Malformed 'upgrade building' entry.";

                 const buildingName = parts[0].trim();
                 const levelMatch = parts[1].match(/(\d+)$/);
                 if (!levelMatch || levelMatch.length < 2) return "Malformed 'upgrade building' entry (level not found).";
                 const targetLevel = parseInt(levelMatch[1], 10);
                 const previousLevel = targetLevel - 1;

                 const buildingDef = buildingManager.get_building(buildingName); // Get definition
                 if (!buildingDef) return `Building definition '${buildingName}' not found for upgrade.`;
                 if (previousLevel < 1) return `Cannot upgrade from level ${previousLevel}.`;

                 // Find the specific building instance at the previous level in the village
                 let building_to_upgrade = null;
                 for (const bd of this.village.buildings) {
                     if (bd.building.name === buildingName && bd.level === previousLevel) {
                         building_to_upgrade = bd; // Found the exact instance
                         break;
                     }
                 }

                 if (building_to_upgrade) {
                     // Simulate the upgrade using the village method (deducts resources)
                     // This will fail if current resources are insufficient, which is correct for replay.
                     if (this.village.upgrade_building(building_to_upgrade)) {
                         // Check level matches log after upgrade (should be targetLevel)
                         if (building_to_upgrade.level !== targetLevel) {
                             console.warn(`Level after upgrading ${buildingName} (${building_to_upgrade.level}) doesn't match log (${targetLevel}). Forcing.`);
                             building_to_upgrade.level = targetLevel; // Force consistency
                         }
                         return null; // Success
                     } else {
                         // Get cost for the intended upgrade
                         const cost = buildingDef.calculate_upgrade_cost(previousLevel);
                         const missing = [];
                         for (const r in cost) {
                             if ((this.village.resources[r] || 0) < cost[r]) {
                                 missing.push(`${r}: ${floor(cost[r] - (this.village.resources[r] || 0))}`);
                             }
                         }
                         const reason = missing.length > 0 ? `insufficient resources (missing ${missing.join(', ')})` : "unknown reason (upgrade_building returned false)";
                         return `Failed to replay 'upgrade ${buildingName} to ${targetLevel}' (${reason})`;
                     }
                 } else {
                     // Could not find the specific building at the expected previous level
                     return `Could not find '${buildingName}' at level ${previousLevel} to replay upgrade.`;
                 }
             } catch (e) {
                 console.error("Error parsing 'upgrade building':", e);
                 return `Error parsing 'upgrade building' entry: ${e.message}`;
             }
        }

        processDeleteBuilding(actionPart) {
             // No bypass check needed for deletion
             try {
                 // Example: "Deleted Woodcutter's Hut (Level 2)"
                 const parts = actionPart.split("Deleted")[1]?.trim().split("(Level");
                  if (!parts || parts.length < 2) return "Malformed 'delete building' entry.";

                 const buildingName = parts[0].trim();
                 const levelMatch = parts[1].match(/(\d+)\)/);
                 if (!levelMatch || levelMatch.length < 2) return "Malformed 'delete building' entry (level not found).";
                 const level = parseInt(levelMatch[1], 10);

                 // Use the village method to delete
                 if (this.village.delete_building(buildingName, level)) {
                     return null; // Success
                 } else {
                     // This indicates the building wasn't found at that level during replay
                     return `Failed to replay 'delete ${buildingName} (Level ${level})' (building not found at that level)`;
                 }
             } catch (e) {
                 console.error("Error parsing 'delete building':", e);
                 return `Error parsing 'delete building' entry: ${e.message}`;
             }
        }

    }


    // --- UI Interaction Functions ---

    function openTab(event, tabName) {
        // Get all elements with class="tab-content" and hide them
        const tabcontent = document.getElementsByClassName("tab-content");
        for (let i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
            tabcontent[i].classList.remove("active");
        }

        // Get all elements with class="tab-button" and remove the class "active"
        const tabbuttons = document.getElementsByClassName("tab-button");
        for (let i = 0; i < tabbuttons.length; i++) {
            tabbuttons[i].classList.remove("active");
        }

        // Show the current tab, and add an "active" class to the button that opened the tab
        document.getElementById(tabName).style.display = "block";
        document.getElementById(tabName).classList.add("active");
        event.currentTarget.classList.add("active");
    }

    function updateStatusTable() {
        if (!appVillage) return;

        const statusTableBody = document.getElementById('statusTableBody');
        statusTableBody.innerHTML = ''; // Clear existing rows

        const total_production = appVillage.calculate_total_production();
        const total_storage = appVillage.calculate_total_storage();
        const resources = ["wood", "iron", "workers", "soldiers"];

        resources.forEach(res => {
            const row = statusTableBody.insertRow();
            row.insertCell().textContent = res.charAt(0).toUpperCase() + res.slice(1);
            row.insertCell().textContent = formatResource(appVillage.resources[res] || 0);
            row.insertCell().textContent = formatResource(total_production[res] || 0);
            row.insertCell().textContent = formatResource(total_storage[res] || 0);
            row.insertCell().textContent = formatResource(appVillage.get_true_modifier(res));
            row.insertCell().textContent = formatResource(appVillage.get_true_storage_modifier(res));
            row.insertCell().textContent = formatResource(goal[res] || 0);
        });

         // Update separate labels
        document.getElementById('hqStatusLabel').textContent = `HQ Level: ${appVillage.hq_level}`;
        const emptySlots = appVillage.hq_level - appVillage.buildings.length;
        document.getElementById('slotStatusLabel').textContent = `Empty Build Slots: ${emptySlots > 0 ? emptySlots : 'No'} (${appVillage.buildings.length}/${appVillage.hq_level})`;

        updateGoalStatusLabel(); // Update the goal status text
    }

    function calculateGoalStatus() {
        if (!appVillage || !goal || (goal.wood <= 0 && goal.iron <= 0 && goal.workers <= 0 && goal.soldiers <= 0)) {
             return null; // No goal set or goal is zero
        }

        const total_production = appVillage.calculate_total_production();
        const wood_production = total_production.wood || 0;
        const iron_production = total_production.iron || 0;
        const worker_production = total_production.workers || 0;
        const soldier_production = total_production.soldiers || 0; // Add soldiers

        const remaining_wood = Math.max(0, (goal.wood || 0) - (appVillage.resources.wood || 0));
        const remaining_iron = Math.max(0, (goal.iron || 0) - (appVillage.resources.iron || 0));
        const remaining_workers = Math.max(0, (goal.workers || 0) - (appVillage.resources.workers || 0));
        const remaining_soldiers = Math.max(0, (goal.soldiers || 0) - (appVillage.resources.soldiers || 0)); // Add soldiers

        // Calculate ticks, handle zero production leading to Infinity
        const ticks_for_wood = wood_production > 1e-9 ? remaining_wood / wood_production : (remaining_wood > 1e-9 ? Infinity : 0);
        const ticks_for_iron = iron_production > 1e-9 ? remaining_iron / iron_production : (remaining_iron > 1e-9 ? Infinity : 0);
        const ticks_for_workers = worker_production > 1e-9 ? remaining_workers / worker_production : (remaining_workers > 1e-9 ? Infinity : 0);
        const ticks_for_soldiers = soldier_production > 1e-9 ? remaining_soldiers / soldier_production : (remaining_soldiers > 1e-9 ? Infinity : 0); // Add soldiers

        // Determine the limiting resource (max ticks)
        const ticks_required = Math.max(ticks_for_wood, ticks_for_iron, ticks_for_workers, ticks_for_soldiers);

        let limiting_resource_str = "N/A";
        if (ticks_required === Infinity) {
            const unreachable = [];
            if (ticks_for_wood === Infinity) unreachable.push("Wood");
            if (ticks_for_iron === Infinity) unreachable.push("Iron");
            if (ticks_for_workers === Infinity) unreachable.push("Workers");
            if (ticks_for_soldiers === Infinity) unreachable.push("Soldiers");
            limiting_resource_str = `Unreachable (${unreachable.join('/')} Production Needed)`;
        } else if (ticks_required > 0) {
             const limiting_resources = [];
             const tolerance = 1e-6; // Tolerance for float comparison
             if (Math.abs(ticks_for_wood - ticks_required) < tolerance) limiting_resources.push("Wood");
             if (Math.abs(ticks_for_iron - ticks_required) < tolerance) limiting_resources.push("Iron");
             if (Math.abs(ticks_for_workers - ticks_required) < tolerance) limiting_resources.push("Workers");
             if (Math.abs(ticks_for_soldiers - ticks_required) < tolerance) limiting_resources.push("Soldiers");
             limiting_resource_str = limiting_resources.join('/');
        } else {
             limiting_resource_str = "Goal Met";
        }

        // Calculate overproduction only if reachable
        let overproduction_wood = 0;
        let overproduction_iron = 0;
        let worker_overproduction = 0; // Can be negative (underproduction)
        let soldier_overproduction = 0; // Can be negative

        if (ticks_required !== Infinity && ticks_required > 0) {
             overproduction_wood = (wood_production * ticks_required) - remaining_wood;
             overproduction_iron = (iron_production * ticks_required) - remaining_iron;
             worker_overproduction = (worker_production * ticks_required) - remaining_workers;
             soldier_overproduction = (soldier_production * ticks_required) - remaining_soldiers;
        }

        return {
            limiting_resource: limiting_resource_str,
            ticks_required: ticks_required,
            overproduction_wood: overproduction_wood,
            overproduction_iron: overproduction_iron,
            worker_overproduction: worker_overproduction,
            soldier_overproduction: soldier_overproduction,
        };
    }

    function updateGoalStatusLabel() {
        const goalStatus = calculateGoalStatus();
        const label = document.getElementById('goalStatusLabel');
        if (goalStatus) {
            const { limiting_resource, ticks_required, overproduction_wood, overproduction_iron, worker_overproduction, soldier_overproduction } = goalStatus;

            let goal_status_text = `Goal Status: Limiting: ${limiting_resource}. `;
            if (ticks_required === Infinity) {
                goal_status_text += `Time: Unreachable.`;
            } else if (ticks_required > 0) {
                goal_status_text += `Time: ${formatResource(ticks_required)} ticks. `;
                const overprod_parts = [];
                const threshold = 0.01; // Threshold to show over/under production
                if (Math.abs(overproduction_wood) > threshold) overprod_parts.push(`Wood ${overproduction_wood >= 0 ? '+' : ''}${formatResource(overproduction_wood)}`);
                if (Math.abs(overproduction_iron) > threshold) overprod_parts.push(`Iron ${overproduction_iron >= 0 ? '+' : ''}${formatResource(overproduction_iron)}`);
                if (Math.abs(worker_overproduction) > threshold) overprod_parts.push(`Workers ${worker_overproduction >= 0 ? '+' : ''}${formatResource(worker_overproduction)}`);
                if (Math.abs(soldier_overproduction) > threshold) overprod_parts.push(`Soldiers ${soldier_overproduction >= 0 ? '+' : ''}${formatResource(soldier_overproduction)}`);

                 if (overprod_parts.length > 0) {
                     goal_status_text += ` Over/Under: ${overprod_parts.join('; ')}.`;
                 }
            } else {
                 goal_status_text = "Goal Status: Goal Met or Exceeded.";
            }
             label.textContent = goal_status_text;
        } else {
            label.textContent = "Goal Status: -";
        }
    }


    function updateUnlockButtons() {
        if (!buildingManager) return;
        const container = document.getElementById('unlockButtonsContainer');
        container.innerHTML = ''; // Clear existing

        const lockedBuildings = buildingManager.get_all_buildings()
            .filter(b => !b.unlocked)
            .sort((a, b) => a.name.localeCompare(b.name));

        if (lockedBuildings.length === 0) {
            container.textContent = "All buildings unlocked.";
        } else {
            lockedBuildings.forEach(building => {
                const button = document.createElement('button');
                button.textContent = `Unlock ${building.name}`;
                button.style.width = '100%';
                button.onclick = () => handleUnlockBuilding(building);
                container.appendChild(button);
            });
        }
    }

    function updateHqUpgradeButton() {
        if (!appVillage) return;
        const button = document.getElementById('upgradeHqButton');
        const canAfford = appVillage.can_upgrade_hq();
        const upgradeCost = appVillage.hq.calculate_upgrade_cost(appVillage.hq_level);

        let costText = "Cost:";
        const costItems = [];
        for (const resource in upgradeCost) {
             const cost = upgradeCost[resource];
             if (cost > 0) {
                 costItems.push(`${resource.charAt(0).toUpperCase()}: ${floor(cost)}`);
            }
        }
        costText += costItems.length > 0 ? ` ${costItems.join(', ')}` : " Max Level?";

        button.innerHTML = `Upgrade HQ (Lv.${appVillage.hq_level} -> Lv.${appVillage.hq_level + 1})<br>${costText}`; // Use innerHTML for line break
        button.disabled = !canAfford;
        button.classList.toggle('can-afford', canAfford);
    }

    function sortBuildings() {
         if (!appVillage) return;
         appVillage.buildings.sort((a, b) => {
             const nameCompare = a.building.name.localeCompare(b.building.name);
             if (nameCompare !== 0) return nameCompare;
             return a.level - b.level; // Sort by level ascending within the same name
         });
         updateBuildingList(); // Refresh display
         // Maybe log the sort action? Depends if it should be replayable. Currently not logged.
    }

    function updateBuildingList() {
        if (!appVillage || !buildingManager) return;
        const container = document.getElementById('buildingListContainer');
        container.innerHTML = ''; // Clear existing

        if (appVillage.buildings.length === 0) {
            container.textContent = "No buildings built.";
            return;
        }

        // Use the already sorted list (or sort if not guaranteed)
        appVillage.buildings.forEach((buildingData, index) => {
            const building = buildingData.building;
            const level = buildingData.level;
            const upgradeCost = building.calculate_upgrade_cost(level);
            const canUpgrade = appVillage.can_upgrade_building(buildingData);

            const itemDiv = document.createElement('div');
            itemDiv.className = 'building-item';

            // Upgrade Button
            const upgradeButton = document.createElement('button');
            let costText = "Cost:";
            const costItems = [];
             for (const resource in upgradeCost) {
                 const cost = upgradeCost[resource];
                 if (cost > 0) {
                     costItems.push(`${resource.charAt(0).toUpperCase()}: ${floor(cost)}`);
                 }
             }
             costText += costItems.length > 0 ? ` ${costItems.join(', ')}` : " Max Level?";
            upgradeButton.textContent = `Upgr. ${building.name} (Lv.${level}) - ${costText}`;
            upgradeButton.onclick = () => handleUpgradeBuilding(buildingData);
            upgradeButton.disabled = !canUpgrade;
            upgradeButton.classList.toggle('can-afford', canUpgrade);

            // Delete Button
            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Del';
            deleteButton.className = 'delete-button';
            deleteButton.onclick = () => handleDeleteBuilding(buildingData);

            itemDiv.appendChild(upgradeButton);
            itemDiv.appendChild(deleteButton);
            container.appendChild(itemDiv);
        });
    }

    function updateModifierInputs() {
        if (!appVillage) return;
         // Scaling Factors (displaying multiplier relative to 1.5 base)
         for (const key in SCALING_FACTORS) {
             const inputId = `sf_${key}`;
             const input = document.getElementById(inputId);
             if (input) {
                 const multiplier = (SCALING_FACTORS[key] || 1.5) / 1.5;
                 input.value = multiplier.toFixed(4);
             }
         }
         // Terrain Modifiers (displaying percentage)
         const resources = ["wood", "iron", "workers", "soldiers"];
         resources.forEach(res => {
             const prodInput = document.getElementById(`tm_${res}_prod`);
             const storInput = document.getElementById(`tm_${res}_stor`);
             if (prodInput) {
                 prodInput.value = ((appVillage.terrain_modifiers[res] || 0.0) * 100).toFixed(2);
             }
             if (storInput) {
                 storInput.value = ((appVillage.terrain_storage_modifiers[res] || 0.0) * 100).toFixed(2);
             }
         });
    }

    function updateAddBuildingButton() {
         if (!appVillage) return;
         const button = document.getElementById('addBuildingButton');
         const limitReached = appVillage.buildings.length >= appVillage.hq_level;
         button.disabled = limitReached;
         button.textContent = limitReached ? "Add Building (Limit Reached)" : "Add Building";
    }

    function updateAllUI() {
        if (!appVillage) return;
        updateStatusTable();
        updateUnlockButtons();
        updateHqUpgradeButton();
        updateBuildingList();
        updateModifierInputs();
        updateAddBuildingButton();
        document.getElementById('tickCounterDisplay').textContent = `Tick: ${tickCounter}`;
        document.getElementById('errorMessage').textContent = ''; // Clear previous errors
    }

    // --- Event Handlers ---

    function handleLoadLog(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            const logContent = e.target.result;
            console.log("Read log file content.");
             // Backup current state (optional, maybe just show error and don't change state)
             // const backupLog = [...logMessages];
             // const backupTick = tickCounter;
             // const backupVillage = cloneVillage(appVillage); // Need a deep clone function if restoring

            // Use the log processor to replay
             const capturedLogs = []; // Capture logs during processing
             const processResult = logProcessor.processLogContent(logContent, (msg) => capturedLogs.push(msg));

             if (processResult.error) {
                 alert(`Error loading log file:\n${processResult.error}`);
                 document.getElementById('errorMessage').textContent = `Load Error: ${processResult.error}`;
                 // Restore backup if implemented
                 // logMessages = backupLog;
                 // tickCounter = backupTick;
                 // appVillage = backupVillage;
                 // updateAllUI();
             } else {
                 // Success: Replace current state with loaded state
                 appVillage = processResult.village;
                 tickCounter = processResult.tickCount;
                 logMessages = capturedLogs; // Use the logs captured during processing

                 console.log("Log file processed successfully. Updating UI.");
                 updateAllUI();
                 alert(`Log file '${file.name}' loaded successfully.`);
             }
             // Reset file input value so the same file can be loaded again after modification
             event.target.value = null;
        };
        reader.onerror = function(e) {
             alert("Error reading file: " + e.target.error);
             document.getElementById('errorMessage').textContent = `File Read Error: ${e.target.error}`;
              event.target.value = null;
        };
        reader.readAsText(file);
    }

    function handleSaveLog() {
         const timestamp = new Date().toISOString().replace(/[-:.]/g, "").slice(0, 15); // YYYYMMDD_HHMMSS
         const suggestedFilename = `village_log_${timestamp}.txt`;
         const logContent = logMessages.join('\n');
         const blob = new Blob([logContent], { type: 'text/plain;charset=utf-8' });

         const link = document.createElement('a');
         link.href = URL.createObjectURL(blob);
         link.download = suggestedFilename;
         link.style.display = 'none';

         document.body.appendChild(link);
         link.click();
         document.body.removeChild(link);

         URL.revokeObjectURL(link.href); // Clean up blob URL
         console.log("Save log triggered.");
    }

    function handleRevert() {
         if (logMessages.length <= 1) { // Keep the "[INITIALIZE]" message
            alert("No actions to revert.");
            return;
         }

         const tempLogMessages = logMessages.slice(0, -1); // Create copy without last message
         const lastAction = logMessages[logMessages.length - 1];

         console.log(`[REVERT] Reverting last action. New log length: ${tempLogMessages.length}`);

         // Reprocess the log messages up to the second-to-last one
         const revertResult = logProcessor.processLogMessages(tempLogMessages); // Don't pass UI logger

         if (revertResult.error) {
             alert(`Failed to revert last action due to processing error:\n${revertResult.error}`);
             document.getElementById('errorMessage').textContent = `Revert Error: ${revertResult.error}`;
             console.error("ERROR: Revert failed during reprocessing.");
             return;
         }

         // Success: Apply the reverted state
         logMessages = tempLogMessages; // Update the actual log
         appVillage = revertResult.village;
         tickCounter = revertResult.tickCount;

         updateAllUI(); // Update UI to reflect reverted state

         console.log("[REVERT] Revert successful.");
         alert(`Successfully reverted last action:\n'${lastAction.split(':', 1).pop().trim()}'`);
    }

    function handleSaveScalingFactors() {
         if (!appVillage) return;
         try {
            const newFactors = {};
            let changed = false;
             for (const key in SCALING_FACTORS) {
                 const inputId = `sf_${key}`;
                 const input = document.getElementById(inputId);
                 if (!input) continue;
                 const multiplierStr = input.value;
                 if (!multiplierStr) throw new Error(`Multiplier for ${key} cannot be empty.`);
                 const multiplier = parseFloat(multiplierStr);
                 if (isNaN(multiplier) || multiplier <= 0) throw new Error(`Multiplier for ${key} must be a positive number.`);

                 const newValue = 1.5 * multiplier;
                 // Only update if the value actually changes significantly
                 if (Math.abs((SCALING_FACTORS[key] || 0) - newValue) > 1e-9) {
                     newFactors[key] = newValue; // Store the actual factor, not multiplier
                     changed = true;
                 }
            }

            if (changed) {
                 // Apply changes to global object
                 Object.assign(SCALING_FACTORS, newFactors);
                 // Format for log message (Python dict style)
                 const logStr = Object.entries(newFactors)
                    .map(([k, v]) => `'${k}': ${v.toFixed(4)}`) // Use single quotes for keys like Python output
                    .join(', ');
                 logMessage(`Tick ${tickCounter}: Updated scaling factors to || {${logStr}}`);
                 alert("Scaling factors updated successfully!");
                 updateAllUI(); // Update UI reflecting changes (e.g., costs might change)
             } else {
                 alert("No changes detected in scaling factors.");
            }
         } catch(e) {
             alert(`Error saving scaling factors: ${e.message}`);
             document.getElementById('errorMessage').textContent = `Scaling Factor Error: ${e.message}`;
         }
    }

    function handleSaveTerrainModifiers() {
        if (!appVillage) return;
        try {
            const resources = ["wood", "iron", "workers", "soldiers"];
            const newTerrainModifiersLog = {};
            let changed = false;

            resources.forEach(res => {
                 // Production
                 const prodInput = document.getElementById(`tm_${res}_prod`);
                 if (prodInput) {
                     const prodValueStr = prodInput.value;
                     const prodValuePercent = parseFloat(prodValueStr);
                     if (isNaN(prodValuePercent)) throw new Error(`Invalid input for ${res} Production %`);
                     const prodValueDecimal = prodValuePercent / 100.0;
                     // Only update if different
                     if (Math.abs((appVillage.terrain_modifiers[res] || 0.0) - prodValueDecimal) > 1e-6) {
                        appVillage.set_terrain_modifier(res, prodValueDecimal);
                        newTerrainModifiersLog[`${res}_production`] = prodValueDecimal;
                        changed = true;
                     }
                 }
                 // Storage
                  const storInput = document.getElementById(`tm_${res}_stor`);
                 if (storInput) {
                     const storValueStr = storInput.value;
                     const storValuePercent = parseFloat(storValueStr);
                     if (isNaN(storValuePercent)) throw new Error(`Invalid input for ${res} Storage %`);
                     const storValueDecimal = storValuePercent / 100.0;
                     // Only update if different
                     if (Math.abs((appVillage.terrain_storage_modifiers[res] || 0.0) - storValueDecimal) > 1e-6) {
                        appVillage.set_terrain_storage_modifier(res, storValueDecimal);
                        newTerrainModifiersLog[`${res}_storage`] = storValueDecimal;
                        changed = true;
                     }
                 }
            });

            if (changed) {
                 // Format for log message (Python dict style)
                 const logStr = Object.entries(newTerrainModifiersLog)
                     .map(([k, v]) => `'${k}': ${v.toFixed(4)}`)
                     .join(', ');
                 logMessage(`Tick ${tickCounter}: Updated terrain modifiers to || {${logStr}}`);
                 alert("Terrain modifiers updated successfully!");
                 updateAllUI(); // Update UI reflecting changes (prod/storage values)
             } else {
                 alert("No changes detected in terrain modifiers.");
            }

        } catch(e) {
             alert(`Error saving terrain modifiers: ${e.message}`);
             document.getElementById('errorMessage').textContent = `Terrain Modifier Error: ${e.message}`;
        }
    }

    function handleApplyEconomyChange() {
         if (!appVillage) return;
         try {
             const multiplierInput = document.getElementById('economyMultiplier');
             const multiplierStr = multiplierInput.value;
             if (!multiplierStr) throw new Error("Multiplier cannot be empty.");
             const multiplier = parseFloat(multiplierStr);
             if (isNaN(multiplier) || multiplier <= 0) throw new Error("Multiplier must be a positive number.");

            let changed = false;
            const newScalingFactorsLog = {};
            for (const key in SCALING_FACTORS) {
                const originalValue = SCALING_FACTORS[key] || 1.5; // Use default if somehow missing
                const newValue = originalValue * multiplier;
                 // Only update if the value actually changes significantly
                 if (Math.abs(originalValue - newValue) > 1e-9) {
                     SCALING_FACTORS[key] = newValue;
                     newScalingFactorsLog[key] = newValue;
                     changed = true;
                 }
            }

            if (changed) {
                const logStr = Object.entries(newScalingFactorsLog)
                     .map(([k, v]) => `'${k}': ${v.toFixed(4)}`)
                     .join(', ');
                 logMessage(`Tick ${tickCounter}: Applied economy change with multiplier ${multiplier.toFixed(4)}. New scaling factors: || {${logStr}}`);
                 alert("Economy change applied successfully!");
                 updateAllUI(); // Update UI reflecting changes (costs, modifier inputs)
             } else {
                 alert(`No significant change in scaling factors with multiplier ${multiplier}.`);
             }
             // Reset entry to 1.0 after applying
             multiplierInput.value = "1.0";

         } catch(e) {
             alert(`Error applying economy change: ${e.message}`);
             document.getElementById('errorMessage').textContent = `Economy Change Error: ${e.message}`;
         }
    }


    function handleUpgradeHQ() {
        if (!appVillage) return;
        if (appVillage.upgrade_hq()) {
            logMessage(`Tick ${tickCounter}: Upgraded HQ to level ${appVillage.hq_level}`);
            updateAllUI();
        } else {
            // Error message is shown by upgrade_hq() itself via alert
            console.warn("HQ Upgrade failed (likely insufficient resources).");
        }
    }

    function handleUnlockBuilding(building) {
         if (!appVillage || !building) return;
         building.unlock(); // Unlock definition in manager
         logMessage(`Tick ${tickCounter}: Unlocked ${building.name}`);
         alert(`${building.name} has been unlocked!`);
         updateAllUI(); // Re-renders unlock buttons and potentially affects add building list
    }

    function handleSimulateTicks(numTicks) {
        if (!appVillage || numTicks <= 0) return;
        appVillage.simulate_ticks(numTicks);
        tickCounter += numTicks;
        // No log message for simulation ticks to avoid bloating the log
        updateAllUI(); // Update resources, etc.
    }

    function handleOpenAddBuildingModal() {
         if (!appVillage || !buildingManager) return;
         if (addBuildingWindowOpen) return; // Prevent multiple modals (basic check)

        if (appVillage.buildings.length >= appVillage.hq_level) {
            alert("Building limit reached. Cannot add more buildings until HQ is upgraded.");
            return;
        }

         const modal = document.getElementById('addBuildingModal');
         const grid = document.getElementById('addBuildingModalGrid');
         grid.innerHTML = ''; // Clear previous buttons

         const unlockedBuildings = buildingManager.get_all_buildings()
             .filter(b => b.unlocked)
             .sort((a, b) => a.name.localeCompare(b.name));

         unlockedBuildings.forEach(building => {
             const initialCosts = building.calculate_costs(1);
             let costText = "Cost:";
             const costItems = [];
              for (const resource in initialCosts) {
                  const cost = initialCosts[resource];
                  if (cost > 0) {
                     costItems.push(`${resource.charAt(0).toUpperCase()}: ${floor(cost)}`);
                  }
              }
             costText += costItems.length > 0 ? ` ${costItems.join(', ')}` : " Free?";

             const button = document.createElement('button');
             button.innerHTML = `${building.name}<br>${costText}`; // Use innerHTML for line break
             button.onclick = () => handleSelectBuildingToAdd(building);
             grid.appendChild(button);
         });

         addBuildingWindowOpen = true;
         modal.showModal(); // Show the HTML dialog modal
         modal.addEventListener('close', () => { addBuildingWindowOpen = false; }, { once: true }); // Reset flag on close
    }

    function handleSelectBuildingToAdd(building) {
         if (!appVillage || !building) return;
         const modal = document.getElementById('addBuildingModal');

         // Check resources *again* right before adding
         const buildingCost = building.calculate_costs(1);
         let canAfford = true;
         const missingStr = [];
         for (const resource in buildingCost) {
            const cost = buildingCost[resource];
             if ((appVillage.resources[resource] || 0) < cost) {
                 canAfford = false;
                 missingStr.push(`${resource}: ${floor(cost - (appVillage.resources[resource] || 0))}`);
             }
         }

         if (!canAfford) {
             alert(`Not enough resources for ${building.name}.\nMissing: ${missingStr.join(', ')}`);
             // Keep modal open
             return;
         }

         // Attempt to add the building using village logic
         if (appVillage.add_building(building, 1)) {
             logMessage(`Tick ${tickCounter}: Added ${building.name} (Level 1)`);
             updateAllUI();
             modal.close(); // Close modal on success
         } else {
             // Error likely shown by add_building, but add a generic one just in case
             alert(`Failed to add ${building.name}. Building limit might be reached or another error occurred.`);
             // Keep modal open
         }
    }

    function handleUpgradeBuilding(buildingData) {
         if (!appVillage || !buildingData) return;
         const buildingName = buildingData.building.name; // Store name before potential modification
         if (appVillage.upgrade_building(buildingData)) {
            // Log uses the *new* level which is now in buildingData.level
             logMessage(`Tick ${tickCounter}: Upgraded ${buildingName} to level ${buildingData.level}`);
             updateAllUI();
         } else {
             // Error message shown by upgrade_building via alert
             console.warn(`Upgrade failed for ${buildingName}`);
         }
    }

    function handleDeleteBuilding(buildingData) {
         if (!appVillage || !buildingData) return;
         const building = buildingData.building;
         const level = buildingData.level;

         if (confirm(`Are you sure you want to delete ${building.name} (Level ${level})?`)) {
             if (appVillage.delete_building(building.name, level)) {
                 logMessage(`Tick ${tickCounter}: Deleted ${building.name} (Level ${level})`);
                 updateAllUI();
             } else {
                 // This case should be rare if the button corresponds to an existing building
                 alert(`Could not delete ${building.name} (Level ${level}). Building might have already been deleted or changed.`);
                 updateAllUI(); // Update list anyway
             }
         }
    }

    // --- Conversion Calculator Handlers ---
    function handleAddConvBuilding() {
         try {
             const buildingSelect = document.getElementById('convBuildingSelect');
             const levelInput = document.getElementById('convLevelInput');
             const quantityInput = document.getElementById('convQuantityInput');
             const listbox = document.getElementById('conversionList');

             const buildingName = buildingSelect.value;
             if (!buildingName) throw new Error("Please select a building.");
             const levelStr = levelInput.value;
             const quantityStr = quantityInput.value;
             if (!levelStr || !quantityStr) throw new Error("Level and quantity cannot be empty.");

             const level = parseInt(levelStr, 10);
             const quantity = parseInt(quantityStr, 10);
             if (isNaN(level) || isNaN(quantity) || level < 1 || quantity < 1) {
                 throw new Error("Level and quantity must be numbers >= 1.");
             }

             // Calculate cumulative cost
             const cumulativeCost = findCumulativeCost(buildingName, level);

             const totalWood = cumulativeCost.wood * quantity;
             const totalIron = cumulativeCost.iron * quantity;
             const totalWorkers = cumulativeCost.workers * quantity;

             const costString = `(${floor(totalWood)} wd, ${floor(totalIron)} ir, ${floor(totalWorkers)} wk)`;
             const displayString = `${quantity}x ${buildingName} (Level ${level}) ${costString}`;

             // Store data in the element for later calculation
             const listItem = document.createElement('li');
             listItem.textContent = displayString;
             listItem.dataset.buildingName = buildingName;
             listItem.dataset.level = level;
             listItem.dataset.quantity = quantity;
             listbox.appendChild(listItem);

             // Clear inputs (optional)
             // levelInput.value = "1";
             // quantityInput.value = "1";
         } catch (e) {
             alert(`Error adding building to list: ${e.message}`);
             document.getElementById('errorMessage').textContent = `Conversion Add Error: ${e.message}`;
         }
    }

     function handleClearConvList() {
         document.getElementById('conversionList').innerHTML = '';
         document.getElementById('totalCostsDisplay').textContent = 'Total Costs: -';
         document.getElementById('totalCostsDisplay').dataset.costs = '{}'; // Clear stored costs
     }

     function handleCalculateTotalCosts() {
         const listbox = document.getElementById('conversionList');
         const displayLabel = document.getElementById('totalCostsDisplay');
         const totalCosts = { wood: 0, iron: 0, workers: 0 };

         try {
             const items = listbox.getElementsByTagName('li');
             for (let i = 0; i < items.length; i++) {
                 const item = items[i];
                 const buildingName = item.dataset.buildingName;
                 const level = parseInt(item.dataset.level, 10);
                 const quantity = parseInt(item.dataset.quantity, 10);

                 if (!buildingName || isNaN(level) || isNaN(quantity)) {
                    console.warn("Skipping invalid list item:", item.textContent);
                    continue;
                 }

                 const cumulativeCost = findCumulativeCost(buildingName, level);
                 for (const resource in cumulativeCost) {
                     if (resource in totalCosts) {
                         totalCosts[resource] += (cumulativeCost[resource] || 0) * quantity;
                     }
                 }
             }

             // Format output
             const formattedCosts = Object.entries(totalCosts)
                 .map(([res, cost]) => `${res.charAt(0).toUpperCase() + res.slice(1)}: ${formatResource(cost)}`)
                 .join('\n');
             displayLabel.textContent = `Total Costs:\n${formattedCosts}`;
             // Store the calculated costs data for the 'Set Goal' button
             displayLabel.dataset.costs = JSON.stringify(totalCosts);

         } catch (e) {
             alert(`Error calculating total costs: ${e.message}`);
             displayLabel.textContent = 'Error calculating costs.';
             displayLabel.dataset.costs = '{}';
             document.getElementById('errorMessage').textContent = `Cost Calc Error: ${e.message}`;
         }
     }

    function handleSetGoal() {
        const displayLabel = document.getElementById('totalCostsDisplay');
         const costsStr = displayLabel.dataset.costs;

         if (!costsStr || costsStr === '{}' || displayLabel.textContent.startsWith("Total Costs: -") || displayLabel.textContent.startsWith("Error")) {
            alert("Please calculate the total costs first.");
            return;
         }

         try {
             const calculatedCosts = JSON.parse(costsStr);
             // Update the global goal object
             goal = {
                 wood: calculatedCosts.wood || 0,
                 iron: calculatedCosts.iron || 0,
                 workers: calculatedCosts.workers || 0,
                 soldiers: goal.soldiers || 0 // Keep existing soldiers goal if any
             };

             updateAllUI(); // Update the status table to show the new goal
             alert(`Goal set successfully:\nWood: ${formatResource(goal.wood)}\nIron: ${formatResource(goal.iron)}\nWorkers: ${formatResource(goal.workers)}`);
         } catch (e) {
             alert("Could not parse calculated costs to set the goal.");
             document.getElementById('errorMessage').textContent = `Set Goal Error: ${e.message}`;
         }
    }

    // --- Scenario Control Handlers ---
    function handleSetHqLevelScenario() {
         if (!appVillage) return;
         const input = document.getElementById('scenarioHqLevel');
         try {
             const levelStr = input.value;
             if (!levelStr) throw new Error("HQ level cannot be empty.");
             const level = parseInt(levelStr, 10);
             if (isNaN(level) || level < 1) throw new Error("HQ level must be an integer >= 1.");

             const oldLevel = appVillage.hq_level;
             appVillage.hq_level = level; // Direct set (bypass)
             logMessage(`Tick ${tickCounter}: Set HQ to level ${level} [BYPASS]`);
             updateAllUI();
             alert(`HQ level set to ${level}.`);
             input.value = ''; // Clear input
         } catch (e) {
             alert(`Error setting HQ level: ${e.message}`);
             document.getElementById('errorMessage').textContent = `Scenario HQ Error: ${e.message}`;
         }
    }

    function handleAddBuildingScenario() {
         if (!appVillage || !buildingManager) return;
         const buildingSelect = document.getElementById('scenarioBuildingSelect');
         const levelInput = document.getElementById('scenarioBuildingLevel');
         try {
             const buildingName = buildingSelect.value;
             if (!buildingName) throw new Error("Please select a building.");
             const levelStr = levelInput.value;
             if (!levelStr) throw new Error("Building level cannot be empty.");
             const level = parseInt(levelStr, 10);
             if (isNaN(level) || level < 1) throw new Error("Building level must be an integer >= 1.");

             const building = buildingManager.get_building(buildingName);
             if (!building) throw new Error(`Building ${buildingName} not found.`);

             // Bypass resource checks and directly add the building
             if (appVillage.buildings.length < appVillage.hq_level) {
                 appVillage.buildings.push({ building: building, level: level });
                 appVillage.calculate_building_modifiers();
                 appVillage.calculate_building_storage_modifiers();

                 logMessage(`Tick ${tickCounter}: Added ${buildingName} (Level ${level}) [BYPASS]`);
                 updateAllUI();
                 alert(`Added ${buildingName} at level ${level}.`);
                 levelInput.value = ''; // Clear input
             } else {
                 alert("Building limit reached. Cannot add more buildings (even with bypass). Upgrade HQ first.");
             }
         } catch (e) {
             alert(`Error adding building (scenario): ${e.message}`);
             document.getElementById('errorMessage').textContent = `Scenario Add Building Error: ${e.message}`;
         }
    }

    function handleSetResourcesScenario() {
         if (!appVillage) return;
         const woodInput = document.getElementById('scenarioWood');
         const ironInput = document.getElementById('scenarioIron');
         const workersInput = document.getElementById('scenarioWorkers');
         try {
             const woodStr = woodInput.value;
             const ironStr = ironInput.value;
             const workersStr = workersInput.value;

             // Use current value if input is empty
             const wood = woodStr ? parseFloat(woodStr) : appVillage.resources.wood;
             const iron = ironStr ? parseFloat(ironStr) : appVillage.resources.iron;
             const workers = workersStr ? parseFloat(workersStr) : appVillage.resources.workers;

             // Basic validation for entered values
             if (woodStr && isNaN(wood)) throw new Error("Invalid wood value.");
             if (ironStr && isNaN(iron)) throw new Error("Invalid iron value.");
             if (workersStr && isNaN(workers)) throw new Error("Invalid workers value.");

             // Set the resources (allow negative for testing if needed, maybe add check later)
             appVillage.resources.wood = wood;
             appVillage.resources.iron = iron;
             appVillage.resources.workers = workers;
             // Keep soldiers unchanged unless an input is added for it
             // appVillage.resources.soldiers = ...;

             logMessage(`Tick ${tickCounter}: Set resources to wood=${formatResource(wood)}, iron=${formatResource(iron)}, workers=${formatResource(workers)} [BYPASS]`);
             updateAllUI();
             alert("Resources set successfully.");
             // Clear inputs
             woodInput.value = '';
             ironInput.value = '';
             workersInput.value = '';

         } catch (e) {
             alert(`Error setting resources: ${e.message}`);
             document.getElementById('errorMessage').textContent = `Scenario Set Resources Error: ${e.message}`;
         }
    }


    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM loaded. Initializing application...");

        // 1. Initialize Building Manager and Definitions
        buildingManager = new BuildingManager();
        if (!buildingManager.load_and_register_definitions(BUILDING_DEFINITIONS)) {
            alert("FATAL ERROR: Could not load building definitions. Check console.");
            document.getElementById('errorMessage').textContent = "Initialization Error: Failed to load building definitions.";
            return; // Stop initialization
        }
        console.log("Building definitions loaded.");

         // Populate building dropdowns
         const allBuildings = buildingManager.get_all_buildings().sort((a,b) => a.name.localeCompare(b.name));
         const convSelect = document.getElementById('convBuildingSelect');
         const scenarioSelect = document.getElementById('scenarioBuildingSelect');
         allBuildings.forEach(b => {
             const option1 = new Option(b.name, b.name);
             const option2 = new Option(b.name, b.name);
             convSelect.add(option1);
             scenarioSelect.add(option2);
         });
         console.log("Building dropdowns populated.");


        // 2. Initialize Village State
        logProcessor = new LogProcessor(); // Create processor instance
         try {
             // Use the processor's method which calls the definition's initial state function
             const initResult = logProcessor.initializeBaseVillage();
             if (initResult) { // Error occurred
                 throw new Error(initResult);
             }
             appVillage = logProcessor.village; // Get the initialized village
             logMessages = []; // Reset logs for the new session
             tickCounter = 0; // Reset ticks
             logMessage("Created base set. [INITIALIZE]", true); // Log initial state internally
             console.log("Initial village state created.");
         } catch (e) {
             alert(`Initialization Error: ${e.message}. Cannot start application.`);
             document.getElementById('errorMessage').textContent = `Initialization Error: ${e.message}`;
             console.error("Village Initialization Failed:", e);
             return; // Stop initialization
         }


        // 3. Attach Event Listeners
        // Load/Save/Revert
        document.getElementById('logFileLoad').addEventListener('change', handleLoadLog);
        document.getElementById('saveLogButton').addEventListener('click', handleSaveLog);
        document.getElementById('revertButton').addEventListener('click', handleRevert);

        // Modifiers & Economy
        document.getElementById('saveScalingFactorsButton').addEventListener('click', handleSaveScalingFactors);
        document.getElementById('saveTerrainModifiersButton').addEventListener('click', handleSaveTerrainModifiers);
        document.getElementById('applyEconomyChangeButton').addEventListener('click', handleApplyEconomyChange);

        // Village Actions
        document.getElementById('upgradeHqButton').addEventListener('click', handleUpgradeHQ);
        document.getElementById('addBuildingButton').addEventListener('click', handleOpenAddBuildingModal);
        document.getElementById('sim1Button').addEventListener('click', () => handleSimulateTicks(1));
        document.getElementById('sim10Button').addEventListener('click', () => handleSimulateTicks(10));
        document.getElementById('sim100Button').addEventListener('click', () => handleSimulateTicks(100));
        document.getElementById('sortBuildingsButton').addEventListener('click', sortBuildings);

        // Conversion Calculator
        document.getElementById('addConvBuildingButton').addEventListener('click', handleAddConvBuilding);
        document.getElementById('clearConvListButton').addEventListener('click', handleClearConvList);
        document.getElementById('calculateCostsButton').addEventListener('click', handleCalculateTotalCosts);
        document.getElementById('setGoalButton').addEventListener('click', handleSetGoal);

         // Scenario Controls
         document.getElementById('setHqLevelButton').addEventListener('click', handleSetHqLevelScenario);
         document.getElementById('addBuildingScenarioButton').addEventListener('click', handleAddBuildingScenario);
         document.getElementById('setResourcesScenarioButton').addEventListener('click', handleSetResourcesScenario);


        // 4. Initial UI Update
        updateAllUI();
        console.log("Application Initialized and UI updated.");
    });

</script>
</body>
</html>